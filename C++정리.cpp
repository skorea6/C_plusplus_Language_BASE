/*
	여태까지 했던 내용들 

		 
	 반복
	 	반복 함수는 for, while 등이 있는데,
		어떠한 실행 코드를 반복적으로 실행할때를 나타낸다.
		그 코드를 어느 주기로 반복할 것인지에 대해서 써주어야한다.
		for문 같은 경우 ()의 처음부분에 변수명(int i)을 쓰고
		중간부분에는 그 변수가 멈출구문(i>10), 
		마지막 부분에는 그 변수가 누적될 (i++),
		이 모든 조건이 만족시킬때 함수가 끝난다.
		 	
	 	
	 배열
	 	배열은 일차원배열이랑 이차원 배열이 있는데,
		함수를 정의하고 int a[20] 이렇게 변수명 뒤에 대괄호를 하고 안에 변수크기를 넣는다.
		그 수만큼 메모리에 변수크기가 할당되서,
		만약 20을 썼다면 0~19까지 인식한다.
		이차원 배열은 int a[20][10] 이렇게 변수명 뒤에 대괄호를 두번쓴다.
		 
	 	
	 문자열
	 	문자열은 string을 쓰는데,
		C는 char를 쓰는 반면, C++은 string을 쓰게 된다.
		C는 변수명 뒤에 변수크기를 선언해야 되는 반면, C++는 변수크기를 선언할 필요 없이,
		메모리가 자동으로 할당해준다. string a;
		string을 비교할때는 그냥 test == "" 를 쓰면 비교가 된다.
		 
		 
		 
		 
		  
	 구조체
	 	구조체는  main 함수에서 정의된 typedef를 불러옴으로써,
		데이터를 쉽게 구조화하고 불러올 수 있다는 장점이 있다.
		
		typedef 명령어를 이용해서 함수 k라는 이름으로 선언하면,
		그 함수를 불러올때는 struct k A; 라고 하고,
		A.변수이름 으로 typedef에 있는 함수 메모리를 쉽게 불러온다.
		
		 	 	
	 	
	 사용자 정의 함수
	 	사용자 정의 함수에는 2가지가 있는데,
		 1번째는 void 매개함수로써, 반환하는 return 값이 존재하지 않으며
		 2번째는 int,string 등의 함수로써, 반환하는 return 값이 존재한다.
		 
		함수를 메인에서 호출하면, 함수로 이동하여 함수에 있는 코드를 실행 한뒤,
		그 return 값을 함수에 넣어버린다.
		
		함수를 전달할때, ()안에 있는 함수도 함께 전달되는데,
		이는 사용자 정의 함수에도 동일한 변수 타입을 적어줘야한다. 
		
		
		사용자 함수는 재사용이 가능하여, 반복적으로 사용하는 경우에 빠르게 호출할
		수 있다는 장점이 있어, 파일의 코드가 간결해질 수 있다.
			
		예를 들어서
		
		int a(int b, int c){
			int d = b+c;
			
			return d;
		}
		
		int k = a('1', '2');
	

	 재귀함수
	 	재귀 함수는 사용자 정의 함수를 재 호출하는 것을 뜻한다. 
	 	사용자 함수에 그 사용자 함수의 이름을 다시 호출함으로써,
		계속 누적이 되면서, 코드가 실행된다.
		
		
		이를 통해 소스 코드가 간편해진다. 
	 	
	 	
	 
	 동적할당
	 	메모리를 관리해주는 것이 동적할당이다. 
	 	동적할당은 메모리를 임의로 삭제할 수도 있다.
		동적할당을 하기 위해서는 malloc 함수를 써야 하는데,
		malloc 함수는 메모리의 크기를 지정해주는 역할을 한다. 
		int *A = malloc(sizeof(int));	 
		
		함수의 크기를 정해주면 메모리 관리가 가능하다.
		포인터도 사용 
		
		
	 
	 포인터
	 	포인터는 타입 뒤에 int *A; 
	 	& 주소 값
		* 포인터 
	 	포인터는 데이터의 주소와 데이터를 연결해주는 역할을 해준다. 
	 	또한, 포인터는 동적할당된  메모리를 연결하고 관리한다.  
			  
			  
	 연결리스트
		연결리스트를 통해서 그 전 데이터가 무엇인지, 그 다음의 데이터가 무엇인지,
		head, node, tail 로 나누어 체계적으로 구성할 수 있다.
		
		다음 데이터를 구하는 next만 쓰면, 단방향 통신이다. 
		다음 데이터를 구할때는 next, 그 전 데이터를 구할때는 prev를 쓰면
		양방향통신이다. 
		
		next 를 쓰면 그 다음 값에 있는 함수를 포인터를 이용해서 찾게 되고,
		prev 를 쓰면 그 전의 값에 있는 함수를 포인터를 이용해서 찾게 된다. 
		
		
	 벡터
		백터는 vector
		vector를 선언할때는 vector vec<int>(1);
		
		vector는 배열과 달리 사용하는 방법이 쉬운데,
		만들어진 함수에 .을 붙여, 배열 맨뒤에 값을 추가한다거나 맨앞에 추가한다거나,
		반면 배열은 for문을 돌려서 일일히 찾는 등의 힘든 노력이 동반되어야 한다....
		
		
		일차원 배열은 뒤에 () 괄호를 붙여서 괄호 안에 배열의 크기를 지정하고,
		이차원 배열은 뒤에 [] 괄호를 붙여서 괄호 안에 배열의 크기를 지정한다. 
		
		
		<sort 오름차순> 
		sort(vec.begin(),vec.end(),less<int>());	

		<sort 내림차순> 
		sort(vec.begin(),vec.end(),greater<int>());
		
		
		vector 안에 함수를 뒤쪽에 넣는 방법:
			vec.push_back("hi"); 
	 	vector 함수의 크기를 얻는 방법:
		 	vec.size(); 
		 
		 	
	 
	 
	 클래스 
	 	클래스는 public, private
		public : 접근이 자유로운 공간 
		private: 접근이 제한되어 있는 공간, 클래스 외부에서 사용할 수 없어, 보안적으로 좋다. 
		
		private으로 접근할때는 this->변수명 을 통해서 클래스 함수 내에서 접근해야한다. 
		
		this는 클래스 객체의 주소값을 저장하는 포인터
		
		human kim; 
		
		구조체에서는 변수를 public, private로 나누지 못하고 안에 함수를 정의하지 못하지만, 
		클래스에서는 이것들이 가능하다. 
		
		class 클래스명{
			private:
				int a;
				string b;
			public:
				int c;
				string d;
				
				void 클래스 내부 함수명(){
					// 초기에 실행될 함수 
				}
				
				void hello(){
					cout << this->a; // Private 호출 
					cout << c; // Public 호출 
					 
				}
		};
		
		
		human kim;
		
		kim.info//()
				
		클래스 객체를 생성할때는
		클래스이름 객체명;
		클래스에 있는  함수를 호출하기 위해서 클래스객체.hello(); 로 호출한다.
		호출이 되면, class 함수의 public에 있는 hello 함수를 찾게 되고,
		그 함수를 실행하고, void 타입이기 때문에 반환되는 값없이 실행이 끝난다.		
*/



